import base64
import io
import logging
from typing import Any

import google.generativeai as genai
from google.generativeai.types import GenerationConfig, HarmBlockThreshold, HarmCategory
from PIL import Image

from .exceptions import ValidationError
from .retry_handler import circuit_breaker_check, map_google_exception, retry_on_failure

logger = logging.getLogger(__name__)


class GeminiImageClient:
    """Client for generating images using Google Gemini API."""

    def __init__(self, api_key: str):
        """
        Initialize the Gemini client.

        Args:
            api_key: Google Gemini API key
        """
        self.api_key = api_key
        self.model: genai.GenerativeModel | None = None

    async def initialize(self) -> None:
        """Initialize the Gemini model."""
        try:
            genai.configure(api_key=self.api_key)

            # Use Gemini 2.0 Flash experimental for image generation (free tier)
            # This model can generate both text and images
            self.model = genai.GenerativeModel("gemini-2.0-flash-exp")

            logger.info("Gemini client initialized successfully")
        except Exception as e:
            mapped_exception = map_google_exception(e)
            logger.exception("Failed to initialize Gemini client: %s", mapped_exception)
            raise mapped_exception from e

    @circuit_breaker_check
    @retry_on_failure(max_attempts=3, base_delay=1.0, max_delay=60.0)
    async def generate_image(self, prompt: str, **kwargs: Any) -> dict[str, Any]:
        """
        Generate an image from a text prompt using Gemini 2.0 Flash experimental.

        Args:
            prompt: Text description of the image to generate
            **kwargs: Additional parameters for image generation

        Returns:
            Dictionary containing image data and metadata

        Raises:
            ValidationError: If the model is not initialized or prompt is invalid
            ModelError: If image generation fails
        """
        if not self.model:
            raise ValidationError("Gemini client not initialized")

        if not prompt or not prompt.strip():
            raise ValidationError("Prompt cannot be empty")

        try:
            # Create a prompt that encourages image generation
            image_prompt = f"Generate an image: {prompt}"

            # Configure generation for image output
            generation_config = GenerationConfig(
                temperature=kwargs.get("temperature", 0.7),
                top_p=kwargs.get("top_p", 0.9),
                top_k=kwargs.get("top_k", 40),
                max_output_tokens=kwargs.get("max_output_tokens", 2048),
            )

            # Generate content with the model
            response = self.model.generate_content(
                image_prompt,
                generation_config=generation_config,
                safety_settings=self._get_safety_settings(
                    kwargs.get("safety_level", "moderate")
                ),
            )

            # Check if the response contains an image
            image_data = None
            mime_type = "image/png"  # Default mime type
            for part in response.parts:
                if hasattr(part, "inline_data") and part.inline_data:
                    # Found image data
                    image_bytes = part.inline_data.data
                    image_data = base64.b64encode(image_bytes).decode("utf-8")
                    mime_type = part.inline_data.mime_type
                    break

            if image_data:
                return {
                    "data": image_data,
                    "mime_type": mime_type,
                    "prompt": prompt,
                    "model": "gemini-2.0-flash-exp",
                    "parameters": kwargs,
                }
            else:
                # Fallback to placeholder if no image was generated
                logger.warning(
                    "No image generated by Gemini, falling back to placeholder"
                )
                response = await self._generate_image_placeholder(prompt)
                return {
                    "data": response["data"],
                    "mime_type": response["mime_type"],
                    "prompt": prompt,
                    "model": "placeholder",
                    "parameters": kwargs,
                }

        except Exception as e:
            mapped_exception = map_google_exception(e)
            logger.exception("Error generating image: %s", mapped_exception)
            # In case of any error, fall back to placeholder
            response = await self._generate_image_placeholder(prompt)
            return {
                "data": response["data"],
                "mime_type": response["mime_type"],
                "prompt": prompt,
                "model": "placeholder-error",
                "parameters": kwargs,
                "error": str(mapped_exception),
            }

    async def _generate_image_placeholder(self, prompt: str) -> dict[str, Any]:  # noqa: ARG002
        """
        Placeholder implementation for image generation.

        This creates a simple colored image with the prompt text.
        In a real implementation, this would call the actual Gemini image API.
        """
        try:
            # Create a simple placeholder image
            width, height = 512, 512
            image = Image.new("RGB", (width, height), color="lightblue")

            # Save to bytes
            img_byte_arr = io.BytesIO()
            image.save(img_byte_arr, format="PNG")
            img_byte_arr.seek(0)

            # Encode to base64
            image_data = base64.b64encode(img_byte_arr.getvalue()).decode("utf-8")

            return {"data": image_data, "mime_type": "image/png"}

        except Exception:
            logger.exception("Error creating placeholder image")
            raise

    def _get_safety_settings(
        self, safety_level: str = "moderate"
    ) -> dict[HarmCategory, HarmBlockThreshold]:
        """Get safety settings for content generation."""
        if safety_level == "strict":
            threshold = HarmBlockThreshold.BLOCK_LOW_AND_ABOVE
        elif safety_level == "permissive":
            threshold = HarmBlockThreshold.BLOCK_ONLY_HIGH
        else:  # moderate
            threshold = HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE

        return {
            HarmCategory.HARM_CATEGORY_HARASSMENT: threshold,
            HarmCategory.HARM_CATEGORY_HATE_SPEECH: threshold,
            HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: threshold,
            HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: threshold,
        }

    async def validate_api_key(self) -> bool:
        """
        Validate the API key by making a simple request.

        Returns:
            True if API key is valid, False otherwise
        """
        try:
            if not self.model:
                await self.initialize()

            # Type assertion since we know model is initialized after the check above
            assert self.model is not None
            # Make a simple test request
            response = self.model.generate_content("Hello")
            return response is not None

        except Exception as e:
            mapped_exception = map_google_exception(e)
            logger.exception("API key validation failed: %s", mapped_exception)
            return False
